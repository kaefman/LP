#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Если возможно представить некую информацию как набор состояний каких-то объектов, то задачу можно решить с помощью графов. Если определить состояния как вершины графа, а переходы из одно состояние в другое - как дуги. Тогда любой алгоритм поиска можно представить как поиск пути из одной вершины в другую, а ответом может быть путь, который приведет к искомой вершине. Такой способ решения не всегда может быть самым эффективным, однако существует огромное количество задач, которые оптимально решаются таким способом (например, пятнашки и т.п.).

Пролог является уобным языком для решения таких задач, так как алгоритмы поиска, с помощью которых и решаются подобные задачи, представляют собой обход дерева. Если при поиске будет достигнута вершна, из которой нет пути, то будет совершен бэктрекинг и поиск другого решения (при поиске в глубину). Это позволяет достаточно удобно решать такого рода задачи.

## Задание

Железнодорожный сортировочный узел устроен так, как показано на рисунке. На левой стороне собрано некоторое число вагонов двух типов(черные и белые), обоих типов по n штук, в произвольном порядке. Тупик вмещает все 2n вагонов. Пользуясь тремя сортировочными операциями (слева в тупик, из тупика направо, слева направо, минуя тупик), собрать вагоны на правой стороне, так, чтобы типы чередовались. Для решения задачи достаточно 3n-1 сортировочных операций.

## Принцип решения

Для решения этой задачи были использованы поиск в глубину, ширину и с итерационным заглублением. Поиск в глубину представляет собой алгоритм, который продлевает пути до тех пор, пока не получит необходимое состояние. Если из какого-то состояния пути нет, происходит бэктрекинг. 
````prolog
dfs_path([X | T], X, [X | T]).  % Поиск в глубину
dfs_path(P, B, R):- prolong(P, P1), dfs_path(P1, B, R).
dfs(A, B, R):- dfs_path([A], B, R).
````

Поиск в ширину ищет самое короткое решение, то есть сначала проверяет, нет ли среди всех продлений текущего состояния искомого состояния, а потом уже продлевает путь, пока не найдет нужное состояние.
````prolog
bfs(A,B,R) :- path([[A]],B,R).   % R - обратный путь
path([[X|T]|_],X,[X|T]). 
path([P|Q],B,R) :- findall(X,prolong(P,X),L),append(Q,L,QL),!,path(QL,B,R).
path([_|Q],B,R) :- path(Q,B,R).
````

Поиск с итерационным заглублением отличается от поиска в глубину только тем, что решением считаются исключительно те пути, длина которых меньше заданного числа. В данной задаче количество передвижений поездов должно быть ограничено 3 * N - 1, где N - количество поездов одного цвета.
````prolog
id_path([X | T], X, [X | T], _).
id_path(P, B, R, N):- N > 0, prolong(P, P1), N1 is N - 1, id_path(P1, B, R, N1).
id(s(X, Y, Z), B, R):- length(X, L), N is 3 * L / 2, id_path([s(X, Y, Z)], B, R, N).
````

Предикат solve использует один из видов поиска, которые описаны выше.
````prolog
solve(X,R):- 
    reverse(X,X1), 
    permutation(X1,Y), 
    bw(Y), 
    bfs(s(X1,[],[]),  % здесь bfs, dfs или id - в зависимости от вида поиска
    s([],[],Y),W), 
    reverse_lists(W,W1), 
    reverse(W1,R), !.
````

## Результаты

Протестировав каждый вид поиска, я пришла к выводу, что для данной задачи каждый вид поиска является одинаково оптимальным. Действительно, в графе имеются только 3 вершины, а также дано однозначное условие конечного результата, то есть мы заранее можем предугадать однозначно короткий маршрут вагонов, который находит с одинаковой скоростью каждый из алгоритмов. 

Если бы не было условия чередования вагонов в правой части, то, на мой взгляд, наиболее быстрым был поиск с итерационным погружением - вагоны просто переместились бы направо в том же порядке, в котором были изначально, гарантировалось бы, что алгоритм будет содержать не более 3 * n - 1 перестановок, и не тратилось бы дополнительное время на поиск других путей (они в данном случае не нужны).

Ниже я приведу тесты, которые показывают, что все виды поиска работают одинаково по времени. Используя в коде каждый из алгоритмов, я получала следующие результаты на свои запросы:
````prolog
?- solve([white,white,white,black,black,black],X).
X = [s([white, white, white, black, black, black], [], []), s([white, white, white, black, black], 
[], [black]), s([white, white, white, black], [black], [black]), s([white, white, white], [black, black], 
[black]), s([white, white], [black, black], [black, white]), s([white, white], [black], [black, white, 
black]), s([white], [black], [black, white, black, white]), s([white], [], [black, white, black, white, 
black]), s([], [], [black, white, black, white, black, white])]

?- solve([white,black,white,black,white,black],X).
X = [s([white, black, white, black, white, black], [], []), s([white, black, white, black, white], 
[], [black]), s([white, black, white, black], [], [black, white]), s([white, black, white], [], 
[black, white, black]), s([white, black], [], [black, white, black, white]), s([white], [], [black, 
white, black, white, black]), s([], [], [black, white, black, white, black, white])]
````

## Выводы

Для решения данной задачи я не выявила лучшего варианта поиска - все они равнозначны. Однако, если следовать условию, в котором сказано, что максимальное количество перестановок - 3 * n - 1, то лучшим алгоритмом поиска является тот, который гарантирует это условие - поиск с итерационным заглублением. На практике же видно, что все три поиска работают одинаково, так что использовать именно этот алгоритм не обязательно. 

Лабораторная работа научила меня совершать различные виды поиска в графах, а также помогла мне лучше разобраться с алгоритмами поиска, ведь реализация этих алгоритмов на Прологе достаточно наглядна. 
