# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Айрапетова Е. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |        3      |



## Введение

Списке в языке Пролог кардинально отличаются от списков в императивных языках. Списки представляют собой структуру, в которой на первом месте стоит голова, а после неё - хвост (либо список может быть пустым). То есть, в конкретный момент имеется доступ лишь к первому элементу списка. Для того, чтобы вставить элемент, например, в конец этого списка, нужно перебрать все элементы. Этот алгоритм чем-то похож на очереди в императивных языках. Помимо этого, элементы списков на Прологе не имеют фиксированного типа данных.

## Задание 1.1: Предикат обработки списка

`delete_three_last(X1,X2)` - удаление трёх последних элементов списка.

Примеры использования:
```prolog
?- delete_three_last([1,12,3,156,41,1,2,3],X).
X = [1, 12, 3, 156, 41].
?- delete_three_last([3,2,0],X).
X = [].
```

Реализация:
```prolog
delete_three_last(_,[],3).
delete_three_last(X1,X2) :- mylen(X1,L), delete_three_last(X1,X2,L), !.
delete_three_last([X|T1],[X|T2],L) :- L1 is L-1, delete_three_last(T1,T2,L1).
```

Реализация без использования стандартных предикатов:
```prolog
delete_three_last_([_,_,_],[]).
delete_three_last_([X|T1],[X|T2]) :- delete_three_last_(T1,T2),!.
```

Каждый раз, пока программа не дошла до трёх последних элементов списка, выполняется этот же предикат для хвоста данного списка. При этом головы исходного и результирующего списка равны. В случае, когда длина исходного списка становится равной 3 (впоследствие отделения головы), обозначается, что в результирующем списке не будет присутствовать этих трёх элементов и начинается бэктрекинг. Длина определяется с помощью mylen (эквивалентный length предикат) в реализации с использованием стандартных предикатов. В другой реализации длина подсчитывается только в том случае, когда начинается бэктрекинг, явным образом (указано, что в списке есть 3 элемента).

## Задание 1.2: Предикат обработки числового списка

`arithmetic_mean(T,X)` - вычисление среднего арифметического элементов списка.

Примеры использования:
````prolog
?- arithmetic_mean([0,3,6,65,1],X).
X = 15.
?- arithmetic_mean([16,51,25,15,2,13,7,3],X).
X = 16.5.
?- arithmetic_mean([21,21,21],X).
X = 21.
````

Реализация:
```prolog
sum([],0).
sum([X|T],S) :- sum(T,S1), S is S1+X.
arithmetic_mean(T,X) :- mylen(T,L), arithmetic_mean(T,X,L).
arithmetic_mean(T,X,L) :- sum(T,S), X is S/L. 
```

Реализация без использования стандартных предикатов:
```prolog
arithmetic_mean_([],0,0).
arithmetic_mean_(T,X) :- arithmetic_mean_(T,S,C), X is S/C,!.
arithmetic_mean_([X|T],S,C) :- arithmetic_mean_(T,S1,C1), S is S1+X, C is C1+1.
```

В первой реализации используется два вспомогатльных предиката - предикат нахождения суммы всех элементов, который описан в этой же части кода, и предикат mylen (определяет длину списка) - эквивалентый стандартному предикату length. Сумма элементов делится на длину списка.
Во второй реализации длина и сумма элементов считаются в процессе выполнения программы - во время каждой процедуры отделения головы от хвоста к одной из переменных (S) прибавляется значение головы, а в другой (C) - единица.

В качестве примера совместного использования этих предикатов я написала предикат, сравнивающий среднее арифметическое всех элементов и среднее арифметическое всех элементов, кроме трёх последних и нахождения разности между ними. С помощью этого предиката можно узнать, как сильно влияют три последних элемента на среднее арифметическое всех элементов списка.

Реализация:
```prolog
error_rate(T,E) :- arithmetic_mean_(T,X), delete_three_last_(T,T1), arithmetic_mean_(T1,Y), E is abs(X-Y),!.
```

Пример использования:
```prolog
?- error_rate([1,2,3,4,5],X).
X = 1.5.
?- error_rate([9,9,9,11,9,10,9,7,8,10,8,9,10],X).
X = 0.023076923076922995.
?- error_rate([3,3,3,3,3,3,3,3],X).
X = 0.
```

## Задание 2: Реляционное представление данных

Реляционное представление данных, как правило, достаточно удобно для понимания. Это не единственное достоинство такого представления данных - например, преимуществом такого представления, по сравнению с другими, является тот факт, что для организации запросов нет необходимости знать организацию конкретной базы данных во внешней памяти, а также строгие правила проектирования, базирующиеся на математическом аппарате, и полная независимость данных. Изменения в прикладной программе при изменении реляционной БД минимальны. 

Однако,БД зачатую занимает достаточно большой объем внешней памяти, а также скорость доступа к данным не самая высокая. Также при довольно большом и разном объеме данных появляется множество "таблиц", что приводит к меньшей читабельности БД, да и не всегда данные можно представить данные в виде таблиц.

В конкретном файле three.pl данные представлены в виде фактов, в которых хранятся данные о группе студента, фамилии и его оценках за разные предметы (в виде списка). Это довольно удобный способ представления данных - при поиске той или иной информации не придется перебирать слишком большое количество фактов, однако во время каждой итерации приходится сохранять большое количество данных, которые могут быть не нужны. Если сравнивать с другими предоставленными файлами, которые в своей лабораторной работе я не использовала, третий файл является "золотой серединой" между большим количеством различных фактов (что может быть слишком затратным по времени) и огромным количеством данных а каждом факте (что очень затратно по памяти). 

В данной лабораторной работе я написала предикаты для поиска среднего балла студента average_mark(S,M), определения, сдал ли студент экзамены (т.е. не на 2) success(S), поиска количества студентов, не сдавших экзамен по определенному предмету amount_of_reexams(S1,C), а также для поиска стундента(ов) с максимальным средним баллом в группе best_in_group(G,Student).

Поиск среднего балла производится с помощью вспомогательного предиката sum. С его помощью находится сумма всех оценок одного студента, а затем делится на длину списка, которая находится с помощью стандартного  length. Чтобы узнать, сдал ли студент экзамены, программа использует предикат member, а точнее, его отрицание, чтобы проверить, что у студента не стоит 2 ни по какому из перечисленных предметов.

Для того, чтобы для данного предмета найти количество не сдавших его студентов, я нааписала вспомогательную функцию grades, которая ищет людей, получивших оценку 2 за данный предмет. В предикате amount_of_reexams с помощью findall находятся все такие студенты и вычисляется длина получившегося списка.

Для поиска лучших студентов в группе (по среднему баллу) я написала дополнительный предикат max, который находит максимум из списка. С помощью findall составляется список всех, кто получил максимальный в группе средний балл.

Примеры использования:
```prolog
?- average_mark('Решетников',X).
X = 4.166666666666667.
?- average_mark('Петров',X).
X = 4.
?- success('Азурин').
false.
?- success('Эксель').
true.
?-amount_of_reexams('Психология',X).
X = 3.
?- amount_of_reexams(X,Y).
X = 'Логическое программирование',
Y = 0 ;
X = 'Математический анализ',
Y = 3 ;
X = 'Функциональное программирование',
Y = 3 ;
X = 'Информатика',
Y = 3 ;
X = 'Английский язык',
Y = 2 ;
X = 'Психология',
Y = 3 ;
?- best_in_group(101,X).
X = ['Безумников', 'Густобуквенникова'].
?- best_in_group(104,X).
X = ['Фулл']
```


## Выводы

В данной лабораторной работе я ознакомилась с таким понятием в логическом программировании, как списки. Эта структура имеет мало общего с теми списками, которые были мне известны раньше - списками в императивных языках. Хотя и процессе выполнения работы возникали некоторые сложности с реализацией и составлением тех или иных алгоритмов, все проблемы при работе с такими данными решались довольно быстро, так как любой алгоритм можно мысленно разбить на несколько более простых. 
